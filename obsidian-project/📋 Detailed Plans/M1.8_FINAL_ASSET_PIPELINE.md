# M1.8: Final Asset Pipeline Architecture

**Author:** Gemini
**Date:** 2024-07-25
**Status:** Finalized
**Supersedes:** `M1.7_ADVANCED_ASSET_PIPELINE.md`

## 1. Overview

This document specifies the final architecture for a comprehensive, high-performance, and resilient asset management system. This system is designed to handle all external media (images, tokens, maps, audio) referenced in a Roll20 campaign, using a robust, multi-stage pipeline that prioritizes local files, falls back to resilient network fetching, and includes optional optimization and post-processing steps.

## 2. Core Principles

- **Idempotency:** Processing the same asset URL multiple times will result in a single, identical output without re-downloading or re-processing.
- **Resilience:** The system must gracefully handle network errors, timeouts, and file I/O issues.
- **Performance:** The system will use a parallel producer-consumer model to maximize throughput.
- **Configurability:** All optimization and post-processing steps (image downscaling, format conversion, tile combination) will be optional and configurable by the end-user.

## 3. The `IAssetMapper` Service

The entire pipeline will be exposed through a single, clean interface:

```csharp
public interface IAssetMapper
{
    // Main method for standard assets
    Task<string?> GetAssetPathAsync(string sourceUrl, string? campaignZipPath = null);

    // Specialized method for scene backgrounds that require cropping/padding
    Task<string?> ProcessSceneBackgroundAsync(string sourceUrl, int targetWidth, int targetHeight, string? campaignZipPath = null);
}
```

## 4. The Asset Processing Workflow

The `AssetMapperService` will implement the following workflow for every asset request:

### Step 1: Check the Central Cache (RavenDB)

The service will first query the `AssetMappings` collection in RavenDB using the `sourceUrl` as the key. 
- **If a record with `Status = Processed` exists:** The `TargetPath` is returned immediately. The process stops here.
- **If a record with `Status = Pending` exists:** The request waits for the record to be updated.
- **If no record exists:** A new record is created with `Status = Pending`, and the `sourceUrl` is added to a thread-safe producer-consumer queue (`System.Threading.Channels.Channel`) for a background worker to process.

### Step 2: The Worker Pipeline

A pool of background workers will execute the following steps for each URL in the queue:

1.  **Check Local ZIP First:** If a `campaignZipPath` was provided, the worker will first attempt to find the asset file within the local ZIP archive. If found, it uses the local file as its source data.

2.  **Network Fetch (Fallback):** If the asset is not found in the ZIP (or no path was provided), the worker will use a resilient HTTP client (configured with **Polly**) to download the asset from the `sourceUrl`. This will include policies for retries on transient errors and timeouts.

3.  **De-duplicate Filename:** The worker will generate a safe, unique filename. It will then atomically `INSERT` this proposed path into a dedicated `FileSystemPaths` collection in RavenDB. If the insert fails (because the path is already taken), it will append a suffix (e.g., `-1`, `-2`) and retry until it successfully claims a unique path. This is a race-condition-proof method for ensuring filename uniqueness.

4.  **Optional: Optimize Assets:** If the user has enabled optimization:
    - **Images:** The worker will use **ImageSharp** to convert the image to **WEBP** and, if it exceeds the configured maximum resolution, downscale it.
    - **Audio/Video:** The worker will shell out to an external **FFmpeg** process to convert the media to **OGG** or **WEBM** with a configurable quality setting.

5.  **Save and Update Cache:** The final, processed asset is saved to the correct subfolder in the output world (`assets/images`, `assets/audio`, etc.). The worker then updates the `AssetMapping` record in RavenDB, setting the `TargetPath` to the final path and updating the `Status` to `Processed`.

## 5. Scene Post-Processing (Tile Combiner)

The **Tile Combiner** is a separate, optional process that runs *after* the main asset pipeline is complete for a given scene.

- **Trigger:** It will be invoked by the `SceneConversionService`.
- **Input:** It will use the `IAssetMapper` to get the final, already-processed paths for the scene background and all its tiles.
- **Process:** It will use **ImageSharp** to composite these images into a single new background file.
- **Output:** The new, combined image will be saved as a new asset, and the scene data will be updated to use it, with the original tiles being removed.

This architecture provides a robust, efficient, and flexible solution for managing all aspects of the asset conversion and optimization process.
