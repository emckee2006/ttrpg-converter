# M2.3: Final Project Architecture

**Author:** Gemini & Alithanna
**Date:** 2024-07-25
**Status:** Finalized

## 1. Overview

This document outlines the final, refactored solution architecture for the TTRPG Converter. The structure is designed to follow modern software engineering principles, emphasizing a clean separation of concerns, maintainability, and testability. The architecture is built around a standard N-tier model with a clear, one-way dependency flow.

## 2. Project Roles and Responsibilities

The solution is divided into four distinct projects, each with a specific and well-defined purpose.

### 2.1. `TTRPGConverter.Core` (The Library)

-   **Purpose:** This is the heart of the application, designed as a pure, self-contained class library. It has no knowledge of the outside world (e.g., no file system, network, or database access).
-   **Contents:**
    -   **`Models/`**: Contains all auto-generated data contracts from schemas (e.g., `Roll20Models.cs`, `FoundryDnd5e.cs`). This directory should be treated as generated-only.
    -   **`Mapping/`**: Contains all AutoMapper profiles, custom resolvers, and the `partial` class extensions needed to support the mapping logic.
-   **Key Principle:** This project can be compiled into a DLL and used by any other application (a future GUI, a web service, etc.) without modification. It has **zero** external dependencies other than the .NET standard libraries and AutoMapper.

### 2.2. `TTRPGConverter.Infrastructure` (The Implementation Details)

-   **Purpose:** This project contains the concrete implementations of the interfaces defined in the Core project. It handles all external concerns and interactions with outside systems.
-   **Contents:**
    -   **`Assets/`**: Contains the `IAssetMapper` interface and its implementation, `AssetMapperService`, which handles all file downloading, caching, and optimization.
    -   **`Compendium/`**: Contains the `ICompendiumManager` and `ICompendiumReader` interfaces and their implementations, which handle all database access (RavenDB, LevelDB, NeDB).
    -   **`Roll20/`**: Contains services like `Roll20CampaignService` responsible for reading and parsing source `.zip` files.
    -   **`Foundry/`**: Contains services like `FoundryWorldBuilder` responsible for writing the final world structure to the disk.
-   **Key Principle:** This is the only project that should contain direct references to external libraries like `Raven.Client`, `ImageSharp`, or perform direct file system I/O.

### 2.3. `TTRPGConverter.Processing` (The Engine)

-   **Purpose:** This project is the "engine" of the application. It contains the high-level services that orchestrate the entire conversion process, using the services and interfaces from the other projects.
-   **Contents:**
    -   **`Conversion/`**: Contains the high-level orchestrators like `CampaignConverter` and `ConversionPipeline`, and data-holding classes like `ConversionContext`.
-   **Key Principle:** The services in this project do not perform low-level work themselves; they delegate those tasks to the services in the `Infrastructure` project.

### 2.4. `TTRPGConverter.CLI` (The User Interface)

-   **Purpose:** This is a thin layer responsible only for handling user input from the command line and displaying output.
-   **Contents:**
    -   `Program.cs`: Contains the dependency injection container setup.
    -   `Commands/`: Contains the command-line argument parsing classes.
-   **Key Principle:** A command class in this project should do nothing more than parse its arguments and make a single call to a high-level service in the `Processing` project.

## 3. Final Dependency Flow

This architecture results in a clean, one-way dependency flow that enhances testability and maintainability.

```mermaid
graph TD
    CLI --> Processing;
    CLI --> Infrastructure;
    Processing --> Core;
    Processing --> Infrastructure;
    Infrastructure --> Core;
    Core -->|None| subgraph end
```

This structure is robust, scalable, and provides a solid foundation for all future development.
