# M1.7: Advanced Asset Pipeline Architecture

**Author:** Gemini
**Date:** 2024-07-25
**Status:** Proposed
**Supersedes:** `M1.6_ASSET_MANAGEMENT_ARCHITECTURE.md`

## 1. Overview

This document outlines the architecture for a high-performance, parallelized asset management system. This system will not only handle the downloading and cross-referencing of assets but will also perform on-the-fly conversion and optimization, including a powerful Tile Combiner feature, to produce modern, efficient Foundry VTT worlds. The design is based on the proven implementation of the `media-optimizer` Foundry VTT module.

## 2. Core Features

-   **Asset Conversion:** Convert all standard image, audio, and video formats to WEBP, OGG, and WEBM respectively.
-   **Image Optimization:** Downscale large images to a configurable maximum resolution (e.g., 8K) and apply quality-based compression.
-   **Tile Combination:** For each scene, combine the background image and all static tiles into a single, flattened background image to dramatically improve rendering performance.
-   **Resilience and Concurrency:** Handle network errors and process multiple assets in parallel without race conditions.

## 3. The Asset Processing Pipeline

The architecture uses a database-backed, producer-consumer model to manage the pipeline.

### 3.1. The `AssetMapping` Document (RavenDB)

A collection named `AssetMappings` will be the central source of truth for all assets.

```csharp
public class AssetMapping
{
    public string Id { get; set; } // Hashed SourceUrl
    public string SourceUrl { get; set; }
    public string? OriginalMimeType { get; set; }
    public string? TargetPath { get; set; } // Final path to the .webp or .ogg file
    public string? TargetMimeType { get; set; }
    public AssetStatus Status { get; set; }
    public int FailedAttempts { get; set; }
}

public enum AssetStatus { Pending, Processed, Failed, Skipped }
```

### 3.2. The Producer-Consumer Workflow

1.  **Producer:** The main conversion process will identify asset URLs and pass them to the `IAssetMapper` service. The service will atomically add a `Pending` record to the `AssetMappings` collection and queue the URL for processing.
2.  **Consumers (Parallel Workers):** A pool of worker threads will execute the following steps for each asset:
    a.  Download the asset to a memory buffer.
    b.  Perform the appropriate conversion and optimization based on the asset type.
    c.  Atomically claim a unique filename in the output directory.
    d.  Save the final, optimized file.
    e.  Update the `AssetMapping` record in RavenDB with the final path and a `Processed` status.

### 3.3. Image Processing (WEBP Conversion & Downscaling)

-   **Library:** `SixLabors.ImageSharp` will be used for all image manipulation.
-   **Process:**
    1.  Decode the downloaded image into an `Image` object.
    2.  Check the image dimensions against the `MaxImageWidth` and `MaxImageHeight` settings.
    3.  If the image is larger than the maximum, resize it using a high-quality resampling algorithm (e.g., `Lanczos3`) while preserving the aspect ratio.
    4.  Encode the final image as WEBP using the configured `WebpQuality` setting.

### 3.4. Audio/Video Processing (OGG/WEBM Conversion)

-   **Tool:** This requires an external dependency on **FFmpeg**.
-   **Process:**
    1.  Save the downloaded asset to a temporary file.
    2.  Execute an `ffmpeg.exe` command-line process with the appropriate arguments to convert the file (e.g., `-c:a libvorbis -q:a 5` for OGG).
    3.  Read the converted file back into a buffer for saving.

## 4. The Tile Combiner (`ISceneProcessor`)

This feature will be implemented as a distinct, post-processing step that runs after a scene has been converted.

### 4.1. Workflow

1.  **Trigger:** The `TileCombinerService` will be called for each converted `FoundryScene`.
2.  **Asset Retrieval:** It will use the `IAssetMapper` to get the final, local file paths for the scene's background image and all of its tile images.
3.  **Image Composition (using ImageSharp):**
    a.  Load the background image as the base canvas.
    b.  Iterate through the scene's `tiles` array, sorted by their `sort` and `elevation` properties to ensure correct Z-ordering.
    c.  For each tile, load its image file.
    d.  **Apply Transformations:** Apply the tile's `rotation`, `alpha`, and `tint` using ImageSharp's transformation APIs.
    e.  **Render Filters (Future Scope):** A mechanism to apply common filter effects (like blur or color adjustments) can be added here.
    f.  Draw the transformed tile image onto the main canvas at the correct `x`, `y` coordinates and with the correct `width` and `height`.
4.  **Save New Asset:** The final, combined canvas is saved as a new, single image file (e.g., `scene-123-combined.webp`).
5.  **Update Scene Data:** The `FoundryScene` document is modified:
    a.  The `background.src` property is updated to point to the new combined image.
    b.  The `tiles` array is cleared, as all the individual tiles have now been rendered into the background.

## 5. Configuration

A new `AssetProcessingOptions` class will provide fine-grained control over the pipeline:

```csharp
public class AssetProcessingOptions
{
    public bool OptimizeImages { get; set; } = true;
    public bool ConvertImagesToWebp { get; set; } = true;
    public int WebpQuality { get; set; } = 75;
    public int MaxImageWidth { get; set; } = 8192;
    public int MaxImageHeight { get; set; } = 8192;

    public bool OptimizeAudio { get; set; } = true;
    public bool ConvertAudioToOgg { get; set; } = true;
    public int OggQuality { get; set; } = 5; // VBR quality scale

    public bool OptimizeVideo { get; set; } = true;
    public bool ConvertVideoToWebm { get; set; } = true;

    public bool CombineTiles { get; set; } = true;
}
```

This comprehensive plan provides a clear path to implementing a professional-grade asset optimization and processing pipeline, resulting in smaller, faster, and more modern Foundry VTT worlds.
