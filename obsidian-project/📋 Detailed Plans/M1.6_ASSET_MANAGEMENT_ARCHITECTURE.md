# M1.6: Asset Management Architecture

**Author:** Gemini
**Date:** 2024-07-25
**Status:** Proposed

## 1. Overview

This document outlines the architecture for a robust, high-performance, and resilient asset management system. This system is a foundational component of the TTRPG Converter, responsible for handling all external assets (images, tokens, maps, audio) referenced in a Roll20 campaign.

The proposed solution uses a database-backed, producer-consumer model to handle assets in a parallel and thread-safe manner, ensuring both performance and data integrity.

## 2. Core Challenges

A naive asset handling system (e.g., downloading files on the fly) presents several critical challenges:

1.  **Redundant Downloads:** A single asset (e.g., a goblin token) may be referenced hundreds of times in a campaign. Downloading the same file repeatedly is extremely inefficient.
2.  **Filename Collisions:** Multiple different assets from different URLs may have the same filename (e.g., `token.png`). Simply saving files with their original names will lead to data corruption as they overwrite each other.
3.  **Network Unreliability:** Network requests can fail. A robust system must be able to handle transient errors and retry failed downloads.
4.  **Concurrency Issues:** In a parallel conversion process, multiple threads attempting to download and write the same file will cause race conditions and crashes.

## 3. The RavenDB-Powered Architecture

To solve these challenges, we will use our existing `compendium.ravendb` database as the central source of truth for all asset-related operations. This approach provides transactional, thread-safe state management.

### 3.1. The `AssetMapping` Document

A new collection, `AssetMappings`, will be created in the database. Each document in this collection will represent a single, unique asset URL and track its conversion state.

```csharp
// In TTRPGConverter.Core.Entities
public class AssetMapping
{
    // The primary key will be the original source URL (hashed for consistency)
    public string Id { get; set; }
    public string SourceUrl { get; set; }

    // The final, unique path in the Foundry world (e.g., "assets/tokens/goblin-1.png")
    public string? TargetPath { get; set; }

    // The status of the asset processing
    public AssetStatus Status { get; set; } 

    // Optional metadata
    public string? MimeType { get; set; }
    public long FileSize { get; set; }
    public int FailedAttempts { get; set; }
}

public enum AssetStatus { Pending, Processed, Failed }
```

### 3.2. The `IAssetMapper` Interface

The public contract for the asset service will be simple and focused.

```csharp
// In TTRPGConverter.Core.Interfaces
public interface IAssetMapper
{
    /// <summary>
    /// Takes a source URL and returns the final, local path for the asset.
    /// This method will orchestrate the entire download, caching, and uniquification process.
    /// </summary>
    Task<string?> GetAssetPathAsync(string sourceUrl);
}
```

## 4. The Producer-Consumer Implementation

The `AssetMapperService` will implement the `IAssetMapper` interface using a high-performance producer-consumer pattern.

1.  **The Producer:**
    -   During the entity mapping process (e.g., in an AutoMapper resolver), when an asset URL is encountered, it will be passed to `IAssetMapper.GetAssetPathAsync()`.
    -   This method will first check the `AssetMappings` collection in RavenDB for an existing entry with a `Status` of `Processed`.
    -   If found, it immediately returns the `TargetPath`.
    -   If not found, it will atomically **add a new record with a `Status` of `Pending`** and add the `SourceUrl` to a thread-safe queue (`System.Threading.Channels.Channel<string>`).

2.  **The Consumers (Parallel Workers):**
    -   A pool of background worker threads will be constantly monitoring the channel.
    -   When a URL appears, a worker will take it and perform the following actions:
        a.  Download the file from the `SourceUrl` (with Polly for resilience).
        b.  Generate a safe, unique filename, handling any potential collisions by checking against the database.
        c.  Save the file to the appropriate directory in the output world.
        d.  Update the corresponding `AssetMapping` record in RavenDB, setting the `TargetPath` and updating the `Status` to `Processed`.

3.  **The `GetAssetPathAsync` Return:**
    -   After adding a new URL to the queue, the `GetAssetPathAsync` method will then wait and poll the database for the `AssetMapping` record to be updated to `Processed`. Once it is, it will return the final `TargetPath`.

## 5. Filename Uniquification

To prevent filename collisions, the asset processing pipeline will use the database to guarantee uniqueness.

1.  A separate collection, `FileSystemPaths`, will be used to register all file paths that have been claimed.
2.  When a consumer has downloaded a file and is ready to save it, it will first attempt to atomically `INSERT` the desired target path into the `FileSystemPaths` collection.
3.  If the insert fails, it knows that path is already taken. It will then append a suffix (e.g., `-1`, `-2`) and retry until it successfully claims a unique path.

This database-driven approach is race-condition-proof and provides a definitive source of truth for all asset and file path allocations.
