# M2.1: AutoMapper Integration Strategy

**Author:** Gemini
**Date:** 2024-07-25
**Status:** Proposed

## 1. Overview

To manage the complexity and scale of the entity conversion process, a dedicated object-to-object mapping library will be integrated into the project. This document outlines the design and implementation plan for using **AutoMapper** as the primary tool for transforming Roll20 data models into their Foundry VTT equivalents.

This strategy avoids hand-written, boilerplate mapping code, leading to a more maintainable, testable, and declarative codebase.

## 2. Rationale

The `ROLL20_FOUNDRY_ENTITY_MAPPING.md` document details several complex mapping scenarios that make manual mapping inefficient and error-prone:

-   **Complex Transformations:** Mapping the flat `attribs` array to nested data structures in Foundry (`Actor.data`).
-   **Conditional Logic:** Handling differences between PC and NPC character sheets (e.g., `hp` vs. `npc_hpbase`).
-   **Repeating Sections:** Parsing Roll20's `repeating_*` sections for inventory, attacks, and spells into distinct Foundry `Item` documents.
-   **Data Type Conversion:** Consistently converting between Roll20's string-based values and Foundry's strongly-typed numbers and booleans.

AutoMapper is designed to solve exactly these problems through a rich set of features like custom resolvers, value converters, and conditional mapping.

## 3. Implementation Plan

### Phase 1: Setup and Configuration (Effort: < 15 minutes)

1.  **Add NuGet Package:** The `AutoMapper.Extensions.Microsoft.DependencyInjection` package will be added to the `TTRPGConverter.Core` project.
    ```bash
    dotnet add src/TTRPGConverter.Core/TTRPGConverter.Core.csproj package AutoMapper.Extensions.Microsoft.DependencyInjection
    ```

2.  **Configure Dependency Injection:** In `Program.cs`, within the `RunConvertCampaignCommand` method, AutoMapper will be registered with the service container.
    ```csharp
    // In Program.cs
    builder.Services.AddAutoMapper(typeof(Program).Assembly);
    ```

3.  **Create Mapping Profile Directory:** A new directory will be created to hold all mapping profiles: `src/TTRPGConverter.Core/Mapping`.

### Phase 2: Implement Core Mapping Profiles

This phase involves creating a dedicated `Profile` class for each major entity conversion.

1.  **`CharacterToActorProfile.cs` (Highest Priority):**
    -   **Task:** Create the primary mapping from a `Roll20Character` to a `FoundryActor`.
    -   **Logic:**
        -   Map simple, direct properties (e.g., `name`, `avatar`).
        -   Create a **Custom Resolver** (`CharacterDataResolver`) to handle the complex logic of parsing the `attribs` array and populating the entire `FoundryActor.data` object.
        -   This resolver will be responsible for abilities, skills, AC, HP, and other core attributes.

2.  **`RepeatingSectionToItemProfile.cs`:**
    -   **Task:** Define mappings for converting the data from repeating sections into Foundry `Item` documents.
    -   **Logic:**
        -   Create separate maps for different item types (e.g., `repeating_inventory` -> `Item` of type `loot`, `repeating_attack` -> `Item` of type `weapon`).
        -   Use **Value Converters** to handle common data transformations (e.g., Roll20's "on"/"off" to booleans).

3.  **`HandoutToJournalProfile.cs`:**
    -   **Task:** Define the mapping from a `Roll20Handout` to a `FoundryJournalEntry`.
    -   **Logic:** This is a simpler mapping but will involve using the `IAssetMapper` (once defined) to handle images embedded in the handout's notes.

### Phase 3: Integration with Services

1.  **Create `Roll20ConverterService.cs`:**
    -   **Task:** Create a new, high-level service that orchestrates the entire conversion process.
    -   **Dependencies:** This service will inject `IMapper` (from AutoMapper), `ICompendiumManager`, and `IAssetMapper`.
    -   **Logic:** Its primary method, `ConvertCampaign`, will iterate through the characters, handouts, etc., from the Roll20 campaign and use the `_mapper.Map()` method to convert each one.

2.  **Update `ConvertCampaignCommand.cs`:**
    -   The command will no longer call the `FoundryWorldBuilder` directly.
    -   It will now call the new `Roll20ConverterService` to run the conversion, and then call the `FoundryWorldBuilder` to write the results to disk.

## 4. Example Implementation: Character-to-Actor Mapping

This will serve as the template for all other mappings.

**File: `src/TTRPGConverter.Core/Mapping/CharacterToActorProfile.cs`**
```csharp
using AutoMapper;
using TTRPGConverter.Core.Models.Roll20;
using TTRPGConverter.Core.Models.Foundry;

public class CharacterToActorProfile : Profile
{
    public CharacterToActorProfile()
    {
        CreateMap<Roll20Character, FoundryActor>()
            .ForMember(dest => dest.Id, opt => opt.MapFrom(src => src.Id))
            .ForMember(dest => dest.Name, opt => opt.MapFrom(src => src.Name))
            .ForMember(dest => dest.Img, opt => opt.MapFrom<AvatarPathResolver>()) // Uses a resolver for asset path
            .ForMember(dest => dest.Data, opt => opt.MapFrom<CharacterDataResolver>()); // Uses a resolver for all complex data
    }
}
```

**File: `src/TTRPGConverter.Core/Mapping/Resolvers/CharacterDataResolver.cs`**
```csharp
using AutoMapper;
using TTRPGConverter.Core.Interfaces;

public class CharacterDataResolver : IValueResolver<Roll20Character, FoundryActor, FoundryActorData>
{
    private readonly ICompendiumManager _compendiumManager;
    private readonly IMapper _mapper;

    public CharacterDataResolver(ICompendiumManager compendiumManager, IMapper mapper)
    {
        _compendiumManager = compendiumManager;
        _mapper = mapper;
    }

    public FoundryActorData Resolve(Roll20Character source, FoundryActor destination, FoundryActorData destMember, ResolutionContext context)
    {
        var actorData = new FoundryActorData();

        // 1. Map simple attributes (AC, HP, Speed, etc.)
        // ... logic to find and convert attributes ...

        // 2. Map abilities (Strength, Dexterity, etc.)
        // ... logic to find and convert abilities ...

        // 3. Map skills from attributes
        // ... logic to find and convert skills ...

        // 4. Process repeating sections into Items
        var inventoryItems = ParseRepeatingSection(source, "inventory");
        var weaponItems = ParseRepeatingSection(source, "attack");
        actorData.Items = inventoryItems.Concat(weaponItems).ToList();

        return actorData;
    }

    private List<FoundryItem> ParseRepeatingSection(Roll20Character character, string sectionName)
    {
        // Logic to group repeating attributes by row ID...
        // For each group:
        //   var item = _mapper.Map<FoundryItem>(row_data);
        //   items.Add(item);
        return new List<FoundryItem>(); // Placeholder
    }
}
```

This structured, resolver-based approach provides a clean, maintainable, and highly testable solution for implementing the conversion logic.
