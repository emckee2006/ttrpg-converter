# M1.5: Database-Driven Architecture

**Author:** Gemini & Alithanna
**Date:** 2024-07-26
**Status:** Implemented

## 1. Overview

This document outlines the final, implemented architecture for the TTRPG Converter. The initial plan to use an in-memory model was discarded in favor of a persistent, database-driven approach to handle large compendia, parallel processing, and asset management. The initial database choice of RavenDB was also superseded.

This architecture uses **Entity Framework Core with a SQLite provider** as its core data layer and features a rich, responsive **GUI built with Avalonia** as its primary user interface.

## 2. Core Problem Addressed

The initial in-memory-per-run strategy presented several critical issues that this architecture solves:

-   **Performance Bottleneck:** Re-processing all source compendia on every run is not scalable. A persistent database cache solves this.
-   **Concurrency Unsafe:** The new architecture provides a safe, robust mechanism for parallel processing.
-   **High Memory Usage:** By offloading storage to a local SQLite database, memory usage is minimized.
-   **Complex State Management:** EF Core and a dedicated service layer handle all data access, simplifying the application logic.

## 3. The EF Core + SQLite Solution

We are using **Entity Framework Core with a SQLite provider** as the central data store for the persistent compendium cache and asset mapping.

### 3.1. Why EF Core + SQLite?

-   **Cross-Platform & Lightweight:** Works seamlessly across all target operating systems with no external dependencies.
-   **Excellent Tooling:** Integrates perfectly with the .NET CLI for migrations and database management.
-   **Industry Standard:** A well-understood, robust, and performant ORM.
-   **Relational Model:** Provides a clear and simple structure for our data.

### 3.2. Data Models & `DbContext`

-   **`TTRPGConverterContext`:** The main EF Core `DbContext` for the application.
-   **`CompendiumItem`:** The core entity representing a single item (monster, spell, etc.) from a compendium pack. Includes an `IsPrimary` flag for de-duplication.
-   **`AssetMapping`:** A simple lookup table to cache remote asset URLs to their downloaded local paths, preventing re-downloads.

## 4. The Compendium Building Process

The `CompendiumCacheBuilder` service is responsible for populating the SQLite database. It uses a highly parallelized Producer-Consumer pattern.

1.  **Producer (`ProduceWorkItems`):** A single thread discovers all compendium packs (both NeDB and LevelDB formats) from the user's Foundry VTT data directory. For LevelDB packs, it uses a PowerShell script (`foundry-extract.ps1`) to extract the data to temporary JSON files. A `SemaphoreSlim` ensures only one script runs at a time to prevent race conditions.
2.  **Consumers (`ConsumeWorkItems`):** A pool of worker threads runs in parallel. Each consumer takes a work item and:
    a.  Reads the pack data (either from a `.db` file or the temporary JSON files).
    b.  Processes the data into `CompendiumItem` objects.
    c.  Saves the new items to the SQLite database via EF Core.
3.  **Live Progress Reporting:** The builder does not return a result. Instead, it uses an `IProgress<BuildProgressReport>` to stream results back to the UI in real-time, providing immediate feedback as each pack is processed.
4.  **Conflict Resolution (`FinalizeCache`):** After all consumers are finished, a final step groups all items by name, type, and system, and intelligently flags the best version of each item as `IsPrimary`.

## 5. The GUI Application

The primary interface for the application is a **GUI built with Avalonia**, following the modern MVVM pattern.

-   **`MainWindowViewModel`:** The core ViewModel that orchestrates all UI logic.
-   **Live-Updating UI:** The ViewModel consumes the `IProgress<BuildProgressReport>` stream from the backend. As new results arrive, it updates `ObservableCollection`s, which causes the UI to update instantly without freezing.
-   **Interactive Results View:** A `TreeView` provides a hierarchical summary of the build process. Users can expand/collapse each module to see the success or failure of individual packs. Results are color-coded for clarity.
-   **Detailed Log:** A separate, auto-scrolling `TextBox` displays detailed log messages, which can be resized with a `GridSplitter`.
-   **User-Friendly Features:**
    -   A `ComboBox` automatically discovers and displays all available modules and systems for testing.
    -   The "Update Compendium" feature uses a native "Save File" dialog, allowing the user to choose where to save their database.

This architecture provides a scalable, reliable, and user-friendly foundation for the entire conversion process.
