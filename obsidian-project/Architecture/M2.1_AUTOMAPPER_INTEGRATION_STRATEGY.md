# M2.1: AutoMapper Integration Strategy

**Author:** Gemini & Alithanna
**Date:** 2024-07-26
**Status:** Adopted

## 1. Overview

To manage the complexity and scale of the entity conversion process, a dedicated object-to-object mapping library will be integrated into the project. This document outlines the design and implementation plan for using **AutoMapper** as the primary tool for transforming Roll20 data models into their Foundry VTT equivalents.

This strategy avoids hand-written, boilerplate mapping code, leading to a more maintainable, testable, and declarative codebase.

## 2. Rationale

The `ROLL20_FOUNDRY_ENTITY_MAPPING.md` document details several complex mapping scenarios that make manual mapping inefficient and error-prone:

-   **Complex Transformations:** Mapping the flat `attribs` array to nested data structures in Foundry (`Actor.data`).
-   **Conditional Logic:** Handling differences between PC and NPC character sheets (e.g., `hp` vs. `npc_hpbase`).
-   **Repeating Sections:** Parsing Roll20's `repeating_*` sections for inventory, attacks, and spells into distinct Foundry `Item` documents.
-   **Data Type Conversion:** Consistently converting between Roll20's string-based values and Foundry's strongly-typed numbers and booleans.

AutoMapper is designed to solve exactly these problems through a rich set of features like custom resolvers, value converters, and conditional mapping.

## 3. Implementation Plan

### Phase 1: Setup and Configuration (Effort: < 15 minutes)

1.  **Add NuGet Package:** The `AutoMapper.Extensions.Microsoft.DependencyInjection` package will be added to the `TTRPGConverter.Infrastructure` project.
2.  **Configure Dependency Injection:** In `App.axaml.cs` (for the GUI) and `Program.cs` (for the CLI), AutoMapper will be registered with the service container: `services.AddAutoMapper(typeof(SomeProfile).Assembly);`
3.  **Create Mapping Profile Directory:** A new directory will be created to hold all mapping profiles: `src/TTRPGConverter.Core/Mapping`.

### Phase 2: Implement Core Mapping Profiles

This phase involves creating a dedicated `Profile` class for each major entity conversion.

1.  **`CharacterToActorProfile.cs` (Highest Priority):**
    -   **Task:** Create the primary mapping from a `Roll20Character` to a `FoundryActor`.
    -   **Logic:**
        -   Map simple, direct properties (e.g., `name`, `avatar`).
        -   Create a **Custom Resolver** (`CharacterDataResolver`) to handle the complex logic of parsing the `attribs` array and populating the entire `FoundryActor.data` object.

2.  **`RepeatingSectionToItemProfile.cs`:**
    -   **Task:** Define mappings for converting the data from repeating sections into Foundry `Item` documents.

3.  **`HandoutToJournalProfile.cs`:**
    -   **Task:** Define the mapping from a `Roll20Handout` to a `FoundryJournalEntry`.

### Phase 3: Integration with Services

1.  **Create `ConversionService.cs` (in `TTRPGConverter.Processing`):**
    -   **Task:** Create a new, high-level service that orchestrates the entire conversion process.
    -   **Dependencies:** This service will inject `IMapper` (from AutoMapper) and other necessary services.
    -   **Logic:** Its primary method, `ConvertCampaignAsync`, will iterate through the entities from the source campaign and use the `_mapper.Map()` method to convert each one.

2.  **Integrate with UI Projects:**
    -   The `MainWindowViewModel` (GUI) and the command classes (CLI) will be updated to call the new `ConversionService`.

## 4. Example Implementation: Character-to-Actor Mapping

This will serve as the template for all other mappings.

**File: `src/TTRPGConverter.Core/Mapping/Roll20ToFoundry/Dnd5e/Profiles/CharacterToActorProfile.cs`**
```csharp
using AutoMapper;
// ... other usings

public class CharacterToActorProfile : Profile
{
    public CharacterToActorProfile()
    {
        CreateMap<Roll20Character, FoundryActor>()
            .ForMember(dest => dest.Img, opt => opt.MapFrom<AvatarPathResolver>()) 
            .ForMember(dest => dest.Data, opt => opt.MapFrom<CharacterDataResolver>());
    }
}
```

This structured, resolver-based approach provides a clean, maintainable, and highly testable solution for implementing the conversion logic.
