using TTRPGConverter.Core.Entities;
using TTRPGConverter.Core.Converters;
using TTRPGConverter.Core.Models.Roll20;
using TTRPGConverter.Core.Models.Foundry;
using System.Text.Json;
using Microsoft.Extensions.Logging;

namespace TTRPGConverter.Core.Services;

/// <summary>
/// Orchestrates end-to-end conversion between TTRPG formats
/// </summary>
public interface IConversionPipeline
{
    Task<string> ConvertRoll20ToFoundryPF2eAsync(string roll20Json);
    Task<string> ConvertFoundryPF2eToRoll20Async(string foundryJson);
}

public class ConversionPipeline : IConversionPipeline
{
    private readonly ILogger<ConversionPipeline> _logger;
    private readonly CharacterConverter _roll20Converter;
    private readonly FoundryPF2eConverter _foundryConverter;
    private readonly JsonSerializerOptions _jsonOptions;

    public ConversionPipeline(ILogger<ConversionPipeline> logger)
    {
        _logger = logger;
        _roll20Converter = new CharacterConverter();
        _foundryConverter = new FoundryPF2eConverter();
        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = true,
            DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
        };
    }

    public async Task<string> ConvertRoll20ToFoundryPF2eAsync(string roll20Json)
    {
        try
        {
            _logger.LogInformation("Starting Roll20 to Foundry PF2e conversion");

            // Parse Roll20 JSON
            var roll20Character = JsonSerializer.Deserialize<Roll20Character>(roll20Json, _jsonOptions);
            if (roll20Character == null)
            {
                throw new ArgumentException("Invalid Roll20 JSON format");
            }

            _logger.LogDebug("Parsed Roll20 character: {CharacterName}", roll20Character.Name);

            // Convert to internal representation
            var internalCharacter = _roll20Converter.ToInternal(roll20Character);
            _logger.LogDebug("Converted to internal representation - Level {Level}, {ItemCount} items, {SpellCount} spells", 
                internalCharacter.Level, internalCharacter.Items.Count, internalCharacter.Spells.Count);

            // Convert to Foundry PF2e format
            var foundryActor = _foundryConverter.FromInternal(internalCharacter);
            _logger.LogDebug("Converted to Foundry PF2e actor with {ItemCount} items", foundryActor.Items.Count);

            // Serialize to JSON
            var foundryJson = JsonSerializer.Serialize(foundryActor, _jsonOptions);
            
            _logger.LogInformation("Successfully converted Roll20 character '{CharacterName}' to Foundry PF2e format", 
                internalCharacter.Name);

            return foundryJson;
        }
        catch (JsonException ex)
        {
            _logger.LogError(ex, "Failed to parse JSON during conversion");
            throw new InvalidOperationException("JSON parsing failed during conversion", ex);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Conversion pipeline failed");
            throw;
        }
    }

    public async Task<string> ConvertFoundryPF2eToRoll20Async(string foundryJson)
    {
        try
        {
            _logger.LogInformation("Starting Foundry PF2e to Roll20 conversion");

            // Parse Foundry JSON
            var foundryActor = JsonSerializer.Deserialize<FoundryPF2eActor>(foundryJson, _jsonOptions);
            if (foundryActor == null)
            {
                throw new ArgumentException("Invalid Foundry PF2e JSON format");
            }

            _logger.LogDebug("Parsed Foundry actor: {ActorName}", foundryActor.Name);

            // Convert to internal representation
            var internalCharacter = _foundryConverter.ToInternal(foundryActor);
            _logger.LogDebug("Converted to internal representation - Level {Level}, {ItemCount} items, {SpellCount} spells", 
                internalCharacter.Level, internalCharacter.Items.Count, internalCharacter.Spells.Count);

            // Convert to Roll20 format
            var roll20Character = _roll20Converter.FromInternal(internalCharacter);
            _logger.LogDebug("Converted to Roll20 character with {ItemCount} items", roll20Character.Items.Count);

            // Serialize to JSON
            var roll20Json = JsonSerializer.Serialize(roll20Character, _jsonOptions);
            
            _logger.LogInformation("Successfully converted Foundry actor '{ActorName}' to Roll20 format", 
                internalCharacter.Name);

            return roll20Json;
        }
        catch (JsonException ex)
        {
            _logger.LogError(ex, "Failed to parse JSON during conversion");
            throw new InvalidOperationException("JSON parsing failed during conversion", ex);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Conversion pipeline failed");
            throw;
        }
    }
}
